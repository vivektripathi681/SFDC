<apex:page controller="SDOC.SDFileUpload" showHeader="{!isMassDocxUpload || bulkDocxConversion}"
lightningStylesheets="true">
<apex:outputPanel rendered="{!NOT(isDocxUpload) && NOT(bulkDocxConversion)}">
  <apex:form >
        <apex:pageBlock >
            <apex:pageBlockSection >
              <strong>1.  Select a File from My Computer</strong><br />
              Click the Browse button to find the file.<br />
              (The file cannot be larger than 5MB.) <br />
              <apex:pageBlockSectionItem > 
              <apex:inputFile value="{!filebody}" filename="{!filename}"/> <apex:messages />
              </apex:pageBlockSectionItem>
              
              <apex:pageBlockSectionItem > 
        <strong>2.  Click the Upload button.</strong><br />
              When the upload is complete the file will added as an attachment to your record. <br />
         </apex:pageBlockSectionItem>
         <apex:pageBlockSectionItem > 
                <apex:commandButton value="Upload" action="{!doUpload}" onclick="showDocxMessage();"/>
              </apex:pageBlockSectionItem>
            
          <apex:outputPanel rendered="{!NOT(isDocxUpload)}">
              <apex:pageBlockSectionItem > 
        <strong>3.  Click Done button.</strong><br />
              Adds your uploaded attachment to the email. <br />
          </apex:pageBlockSectionItem>
          <apex:pageBlockSectionItem > 
                <apex:commandButton value="Done" action="{!clear}" disabled="{!filename==null}" onclick="parent.refreshal();parent.YAHOO.force.com.hideEmail();"/>              
            </apex:pageBlockSectionItem>
          </apex:outputPanel>
            
            </apex:pageBlockSection>         
         </apex:pageBlock>
  </apex:form>
</apex:outputPanel>

<apex:outputPanel rendered="{!isDocxUpload}">
  <div id="docxUploadStatus" style="font-size: 24px; font-weight: bold;"></div>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Create .zip files using Javascript. Provides a simple API to place any content generated by Javascript into a .zip file for your users." />

  <apex:includeScript value="{!URLFOR($Resource.SDOC__SDoc, 'jquery-1.8.3.min.js')}"/>
  <apex:includeScript value="{!URLFOR($Resource.SDOC__SDoc, 'jszip.js')}"/>
  <apex:includeScript value="{!URLFOR($Resource.SDOC__SDoc, 'jszip-utils.js')}"/>
  <apex:outputPanel rendered="{!NOT(isMassDocxUpload)}">
    <style type="text/css">
      body { background-color: #F8F8F8; }
    </style>
  </apex:outputPanel>
  <apex:outputPanel rendered="{!isMassDocxUpload}">
    <style type="text/css">
      .error_div { color: #e74c3c; }
    </style>
    <br />
    <div style="font-size: 18px; font-weight:bold;">S-Docs DOCX Template Upload</div>
    <br />
    <div><em>An S-Docs Template will be created for each DOCX file uploaded.</em></div>
    <br />
    <apex:form > 
      Related To Type:&nbsp;
      <apex:selectList id="base_object" size="1" required="true">
        <apex:selectOptions value="{!baseObjects}" />
      </apex:selectList>
    </apex:form> 
  </apex:outputPanel>

  <br />

  <apex:outputPanel rendered="{!msxUploadFiletype == 'DOCX'}">
    <input type="file" id="file_docx_input" name="file" accept=".docx" multiple="multiple" />
  </apex:outputPanel>

  <apex:outputPanel rendered="{!msxUploadFiletype == 'PPTX'}">
    <input type="file" id="file_docx_input" name="file" accept=".pptx" multiple="multiple" />
  </apex:outputPanel>

  <span>
    Legacy syntax: <input type="checkbox" id="is_advanced_upload" />
  </span>
  <br />
  <br />
  <br />

  <div id="upload_results" style="font-size: 14px;"></div>

  <br />
  <br />
  <br />
  <apex:form >
  <apex:actionFunction action="{!doNothing}" name="rerenderElements" reRender="previous_docx_templates" />
    <apex:outputPanel id="previous_docx_templates" rendered="{!NOT(ISNULL(lastDocxUploaded))}">
      <apex:commandButton value="Download most recently uploaded DOCX" reRender="previous_docx_templates"
      onclick="window.open('/servlet/servlet.FileDownload?file={!lastDocxUploaded.Id}', '_blank');" />
    </apex:outputPanel>
  </apex:form>

  <script type="text/javascript">
  /* All these variables can be accessed by the function addAttachmentsToTemplate(),
  as well as the self-executing anonymous function below */
  /* This is the div that will contain the list of upload results in a bulk .docx upload */
  var $result = $("#upload_results");
  /* This is the input containing the uploaded .docx file(s) */
  var $fileDocxInput = $("#file_docx_input");
  /* Create a list the append upload statuses to for mass .docx upload */
  var $fileContent = $("<ul>");
  /* isMassUpload true if the URL is /apex/SDFileUpload?isDocxUpload=true
  and if URL does not contain the query parameter docxTemplateId (as this parameter
  is only used for single .docx upload in the template editor) */
  var isMassUpload = false;
  var docxTemplateId = '{!$CurrentPage.parameters.docxTemplateId}';
  if (docxTemplateId !== '') {
    /* For one-at-a-time .docx uploads (as in the template editor), remove 'multiple'
    from the "Choose Files" input so that users cannot upload more than one file at a time */
    $fileDocxInput.removeAttr('multiple');
  } else {
    isMassUpload = true;
  }
  /* Track the last number file so that if user uses the "Choose Files" input to upload
  .docx files multiple times in the same session, we can use it to make sure we aren't
  overwriting the upload statuses from the previous "Choose Files" upload */
  var lastFileNum = 0;
  /* Enclose the filename in between these two tags and append the error message after errorEnd */
  var errorStart = "<span class='error_div'>Error uploading ";
  var errorEnd = ": </span>";
  /* timeout was 30000 in the first version but was increased since larger files need more time
  (however note that providing an unlimited timeout often results errors) */
  var vfRemotingConfig = { buffer: false, escape: true, timeout: 60000 }; 

  (function () {
    if (!window.FileReader || !window.ArrayBuffer) {
      $("#error_block").removeClass("hidden").addClass("show");
      return;
    }

    $fileDocxInput.on("change", function(evt) {
      /* Add "Upload Status" header to the list of upload statuses after
      user uploads first batch of .docx files */
      if (isMassUpload) {
        $result.html("<div style='font-size:14px; font-weight:bold;'>Upload Status</div>");
      }

      /* Closure to capture the .docx file information. */
      function handleFile(f, fileNum) {
        var errorIntro;
        var $thisDocxUploadStatus;
        if (isMassUpload) {
          errorIntro = errorStart + f.name + errorEnd;
          $result.append($fileContent);
          /* Add list element to keep track of this file's upload status */
          $fileContent.append("<li id='docx-upload-" + fileNum +"'>Uploading " + f.name + "...</li>");
          $thisDocxUploadStatus = $("#docx-upload-" + fileNum);
          
        }

        /* Read the .docx file Blob */
        JSZip.loadAsync(f)
        .then(function(zip) {
            /* Single-docx upload functionality for SDFileUpload iframe in SDTemplateEditor */
            if (!isMassUpload) {
              $result.html("Uploading {!msxUploadFiletype} file...");
              addAttachmentsToTemplate(f, zip, docxTemplateId, null);
            }

            /* Mass upload for /apex/SDOC__SDFileUpload?isDocxUpload=true */
            else {
              Visualforce.remoting.Manager.invokeAction(
                '{!$RemoteAction.SDFileUpload.createNewSDocTemplate}',
                f.name, 
                $("select[id*='base_object']").val(),
                function (result, event) { // Callback for the JS Remoting function.
                  if (event.status) {
                    /* result.Id is Id of newly created S-Doc Template;
                    zip is the object corresponding to this .docx */
                    addAttachmentsToTemplate(f, zip, result.Id, fileNum);
                  } 
                  else {
                    var errorMsg = errorIntro + event.message;
                    //alert(errorMsg); // Uncomment for debugging
                    $thisDocxUploadStatus.html(errorMsg);
                  }
                },
                vfRemotingConfig
              );
            }

        }, function (e) {
            var errorMsg = errorIntro + e.message;
            //alert(errorMsg); // Uncomment for debugging
            $thisDocxUploadStatus.html(errorMsg);
        });
      }

      /* Process each file in the "Choose Files" file input */
      var files = evt.target.files;
      for (var i = 0; i < files.length; i++) {
        handleFile(files[i], lastFileNum + i);
        lastFileNum++;
      }
      /* Once all the files have been sent over to handleFile, 
      clear contents of the file input so users can re-upload the same .docx */
      $fileDocxInput.val(''); 
    });
  })();

  function addAttachmentsToTemplate(f, zip, templateId, fileNum) {
    var $thisDocxUploadStatus;
    if (isMassUpload) {
      $thisDocxUploadStatus = $("#docx-upload-" + fileNum);
    } 
    else {
      $thisDocxUploadStatus = $result;
    }
    var errorIntro = errorStart + f.name + errorEnd;
    Visualforce.remoting.Manager.invokeAction(
      '{!$RemoteAction.SDFileUpload.deleteOldAttachments}',
      templateId,
      function (result, event) { // Callback for the JS Remoting function.
          if (event.status) { } 
          else {
            $thisDocxUploadStatus.html(errorIntro + event.message);
          }
      },
      vfRemotingConfig
    );

    var numFilesInDocx = 0;
    zip.forEach(function (relativePath, zipEntry) {
        numFilesInDocx++;
    });
    
    var numFilesUploaded = 0;
    zip.forEach(function (relativePath, zipEntry) {
      zipEntry.async("base64").then(function (data64) {
        Visualforce.remoting.Manager.invokeAction(
          '{!$RemoteAction.SDFileUpload.uploadInnerDocxFile}',
          zipEntry.name, 
          data64, 
          templateId,
          function (result1, event1) { // Callback for the JS Remoting function.
            if (event1.status) {
              numFilesUploaded++;
              if (numFilesUploaded == numFilesInDocx) {

                // Process bulk DOCX upload in normal Apex (i.e. Apex not executed within an Apex Job)
                if (isMassUpload) {
                  Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.SDFileUpload.preprocessDocxTemplate}',
                    templateId,
                    false,
                    function (result2, event2) { // Callback for the JS Remoting function.
                      if (event2.status) {
                        $thisDocxUploadStatus.html("Successfully created an S-Docs Template for <strong>" + f.name + "</strong>!");
                      } 
                      else {
                        var errorMsg = errorIntro + event2.message;
                        // If the user got the Apex CPU error while uploading a DOCX in the bulk upload,
                        // it means their DOCX took too long to process under normal apex. Since the
                        // individual upload in the Template Editor is a more generous Queuable Job,
                        // the user should try uploading there and see if that provides enough time for processing
                        if (event2.message === 'Apex CPU time limit exceeded') {
                          errorMsg += '. Please head over to the S-Docs Templates tab, create a single S-Docs Template record, '
                            + 'select DOCX for Template Format, '
                            + 'and try uploading the DOCX file from the Template Editor, as this allows for more processing time.';
                        }
                        //alert(errorMsg); // Uncomment for debugging
                        $thisDocxUploadStatus.html(errorMsg);
                      }
                    },
                    vfRemotingConfig
                  );
                }

                // Process an individual DOCX uploaded in the template editor like so: 
                // After uploading DOCX, send it to a Queuable Job for processing and 
                // listen on its status until it has completed or failed
                else {
                  Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.SDFileUpload.preprocessDocxTemplateAsync}',
                    templateId,
                    document.getElementById('is_advanced_upload').checked,
                    function (result2, event2) { // Callback for the JS Remoting function.
                      if (event2.status) {

                        // Listen on Apex Job Status until it has completed or failed
                        var intervalId = setInterval(function() {
                          Visualforce.remoting.Manager.invokeAction(
                            '{!$RemoteAction.SDFileUpload.getJobStatus}',
                            result2,
                            function (result3, event3) { // Callback for the JS Remoting function.
                              if (event3.status) {
                                var jobFailed = result3['NumberOfErrors'] !== 0
                                  || result3['Status'] === 'Failed'
                                  || result3['Status'] === 'Aborted';
                                if (jobFailed) {
                                  var errorMsg = errorIntro + result3['ExtendedStatus'];
                                  //alert(errorMsg); // Uncomment for debugging
                                  $result.html(errorMsg);
                                  clearInterval(intervalId); // Job has failed; stop checking the Apex Job status
                                } else if (result3['Status'] === 'Completed') {
                                  $result.html("Successfully uploaded <strong>" + f.name + "</strong>! You may now use this template to generate documents.");
                                  clearInterval(intervalId); // Job has completed; stop checking the Apex Job status
                                }
                              } 
                              else {
                                var errorMsg = errorIntro + event3.message;
                                //alert(errorMsg); // Uncomment for debugging
                                $thisDocxUploadStatus.html(errorMsg);
                              }
                            },
                            vfRemotingConfig
                          );
                        }, 3000);

                      } 
                      else {
                        var errorMsg = errorIntro + event2.message;
                        //alert(errorMsg); // Uncomment for debugging
                        $thisDocxUploadStatus.html(errorMsg);
                      }
                    },
                    vfRemotingConfig
                  );
                }

              }
            } else {
              var errorMsg = errorIntro + event1.message;
              //alert(errorMsg); // Uncomment for debugging
              $thisDocxUploadStatus.html(errorMsg);
            }
          },
          vfRemotingConfig
        );
      });
    });

    var reader = new FileReader();
    reader.readAsDataURL(f);
    reader.onload = function () {
      var fileBody = reader.result;
      // Upload the complete .docx itself
      Visualforce.remoting.Manager.invokeAction(
        '{!$RemoteAction.SDFileUpload.uploadFile}',
        f.name,
        fileBody.substring(fileBody.indexOf(",") + 1),
        templateId,
        function (result, event) { // Callback for the JS Remoting function.
          if (event.status) { } 
          else {
            var errorMsg = errorIntro + event.message;
            //alert(errorMsg); // Uncomment for debugging
            $thisDocxUploadStatus.html(errorMsg);
          }
        },
        vfRemotingConfig
      );
    };
    reader.onerror = function (error) {
     alert('Error archiving .docx file: ', error);
    };
  }
  </script>
</apex:outputPanel>

<apex:outputPanel rendered="{!bulkDocxConversion}">
  <div style="width: 500px;">
    <apex:form >
      <br />
      <div style="font-size: 18px; font-weight:bold;">S-Docs DOCX Bulk Template Conversion</div>
      <br />
      <br />
      <strong>1. Define the template format and the template's base object.</strong>
      <br />
      Template Format: &nbsp;
      <apex:selectList value="{!bulkConversionTemplateFormat}" size="1">
        <apex:selectOptions value="{!templateFormats}" />
      </apex:selectList>
      <br />
      <br />
      Related To Type: &nbsp;
      <apex:selectList value="{!bulkConversionRelatedToType}" size="1">
        <apex:selectOptions value="{!baseObjects}" />
      </apex:selectList>
      <br />
      <br />
      <strong>2. Upload the DOCX files you'd like to convert.</strong>
      <br />
      <em>Once you upload your files, we'll make a small change to each file, and the files 
      will be automatically downloaded back to your computer as a zip file.</em>
      <br />
      <input type="file" id="file_docx_input" name="file" accept=".docx" multiple="multiple" />
      <br />
      <br />
      <strong>3. Extract all the files in the zip file into a new folder on your computer.</strong>
      <br />
      <br />
      <strong>4. Open one of the DOCX files you in your new folder.</strong>
      <br />
      <em>It doesn't matter which DOCX you open.</em>
      <br />
      <br />
      <strong>5. Insert the rest of the DOCX files in your new folder into the document currently open in Microsoft Word.</strong>
      <br />
      <em>For instructions on doing this, <a href="https://support.office.com/en-us/article/Insert-a-document-in-Word-274128e5-4da7-4cb8-b65f-3d8b585e03f1">click here.</a></em>
      <br />
      <br />
      <strong>6. Paste the contents of your current Word document into the editor below.</strong>
      <br />
      <em>To do this, click the "Paste From Word" icon in the toolbar of the below text editor (a dialog will appear).
      Select everything in the document currently open in Microsoft Word and copy+paste the contents
      into the dialog that opened when you clicked the "Paste From Word" icon in the toolbar of the below text editor.</em>
      <apex:inputTextarea value="{!bulkConversionTemplatesHtml}" id="editor1" styleClass="ckeditor1" />
      <br />
      <br />
      <strong>7. Click the following button to create your S-Docs Templates.</strong>
      <br />
      <apex:commandButton id="conversionBtn" 
      value="Create S-Docs Templates" 
      action="{!bulkConversionCreateTemplates}" 
      onclick="alert('Creating S-Docs Templates...');" />
    </apex:form>
  </div>

  <apex:includeScript value="{!URLFOR($Resource.SDOC__ckEditor,'/ckeditor/ckeditor.js')}"/>
  <apex:includeScript value="{!URLFOR($Resource.SDOC__SDoc, 'jquery-1.8.3.min.js')}"/>
  <apex:includeScript value="{!URLFOR($Resource.SDOC__SDoc, 'jszip.js')}"/>
  <apex:includeScript value="{!URLFOR($Resource.SDOC__SDoc, 'jszip-utils.js')}"/>
  <apex:includeScript value="{!URLFOR($Resource.SDOC__SDoc, 'FileSaver.js')}"/>
  <script type="text/javascript">
  /* This is the input containing the uploaded .docx file(s) */
  var $fileDocxInput = $("#file_docx_input");
  var allDocxsZip;
  var numDocxFiles;
  var numDocxFilesEdited;
  (function () {
    if (!window.FileReader || !window.ArrayBuffer) {
      $("#error_block").removeClass("hidden").addClass("show");
      return;
    }

    $fileDocxInput.on("change", function(evt) {
      /* Closure to capture the .docx file information. */
      function handleFile(f) {
        var editedDocx = new JSZip();
        /* Read the .docx file Blob */
        JSZip.loadAsync(f)
        .then(function(originalDocx) {
          var numFilesInDocx = 0;
          var numFilesInDocxProcessed = 0;
          originalDocx.forEach(function (relativePath, zipEntry) { 
            numFilesInDocx++;
          });
          originalDocx.forEach(function (relativePath, zipEntry) {
            zipEntry.async("text").then(function (data) {
              if (zipEntry.name === 'word/document.xml') {
                data = data.replace(
                  '</w:body>', 
                  '<w:p><w:r><w:t>'
                    + '####NAME####[' + f.name + ']####END_NAME####'
                    + '</w:t></w:r></w:p></w:body>'
                );
              }
              editedDocx.file(zipEntry.name, data);
              numFilesInDocxProcessed++;
              if (numFilesInDocxProcessed === numFilesInDocx) {
                editedDocx.generateAsync({type:"blob"})
                .then(function(contentSingle) {
                  allDocxsZip.file(f.name, contentSingle);
                  numDocxFilesEdited++;
                  if (numDocxFilesEdited === numDocxFiles) {
                    allDocxsZip.generateAsync({type:"blob"})
                    .then(function(contentAll) {
                      saveAs(contentAll, 'altered_docx_files.zip');
                    });
                  }
                });
              }
            });
          });
        }, function (e) {
            var errorMsg = e.message;
            alert(errorMsg);
        });
      }

      /* Zip file that will contain all the edited DOCX files */
      allDocxsZip = new JSZip();

      /* Process each file in the "Choose Files" file input */
      var files = evt.target.files;
      numDocxFiles = files.length;
      numDocxFilesEdited = 0;
      for (var i = 0; i < files.length; i++) {
        handleFile(files[i]);
      }
      /* Once all the files have been sent over to handleFile, 
      clear contents of the file input so users can re-upload the same .docx's */
      $fileDocxInput.val(''); 
    });
  })();













  bind = function(){

  var CKEDITOR_BASEPATH = '{!URLFOR($Resource.SDOC__ckEditor,'ckeditor/')}';
  CKEDITOR.editorConfig = function( config )
          {
              config.height = '100';
      //        config.autoGrow_onStartup = true;
      //        config.autoGrow_minHeight = 400;
      //        config.autoGrow_bottomSpace = 25;
              // Define changes to default configuration here. For example:
              config.defaultLanguage = 'en';
              config.filebrowserBrowseUrl = '{!$Page.SDOC__SDFileList}';
              config.filebrowserUploadUrl = '{!$Page.SDOC__SDFileUpload}';
              config.filebrowserImageBrowseUrl = '{!$Page.SDOC__SDFileList}';
              config.filebrowserImageUploadUrl = '{!$Page.SDOC__SDFileUpload}';
      //        config.filebrowserWindowWidth = '640';
      //        config.filebrowserWindowHeight = '480';
              config.enterMode = CKEDITOR.ENTER_BR;
              config.shiftEnterMode = CKEDITOR.ENTER_P;
              config.allowedContent = true;
              config.FormatSource = false;
              config.FormatOutput = false;
              config.removePlugins = 'fixed, autogrow';

              // Paste from Word fix 11/1/17
              config.pasteFromWordRemoveFontStyles = false;
              config.pasteFromWordRemoveStyles = false;

      //        config.fullPage = true;
      //        config.extraPlugins = 'tableresize';
              CKEDITOR.dtd.$removeEmpty['span']=false;
      //        config.extraPlugins = 'resize';
      //        config.resize_maxWidth = '800';
      //        config.forceSimpleAmpersand = true;
              config.toolbar_Full =
              [
              ['PasteFromWord'],
              ];

              config.toolbar_UserChoices = [
              ];
          };

          // Added 9/15/17 to add support for <span arabic="true">
          CKEDITOR.stylesSet.add( 'default', [
            /* Block Styles */

            // These styles are already available in the "Format" combo ("format" plugin),
            // so they are not needed here by default. You may enable them to avoid
            // placing the "Format" combo in the toolbar, maintaining the same features.
            /*
            { name: 'Paragraph',    element: 'p' },
            { name: 'Heading 1',    element: 'h1' },
            { name: 'Heading 2',    element: 'h2' },
            { name: 'Heading 3',    element: 'h3' },
            { name: 'Heading 4',    element: 'h4' },
            { name: 'Heading 5',    element: 'h5' },
            { name: 'Heading 6',    element: 'h6' },
            { name: 'Preformatted Text',element: 'pre' },
            { name: 'Address',      element: 'address' },
            */

            { name: 'Italic Title',   element: 'h2', styles: { 'font-style': 'italic' } },
            { name: 'Subtitle',     element: 'h3', styles: { 'color': '#aaa', 'font-style': 'italic' } },
            {
              name: 'Special Container',
              element: 'div',
              styles: {
                padding: '5px 10px',
                background: '#eee',
                border: '1px solid #ccc'
              }
            },

            /* Inline Styles */

            // These are core styles available as toolbar buttons. You may opt enabling
            // some of them in the Styles combo, removing them from the toolbar.
            // (This requires the "stylescombo" plugin)
            /*
            { name: 'Strong',     element: 'strong', overrides: 'b' },
            { name: 'Emphasis',     element: 'em' , overrides: 'i' },
            { name: 'Underline',    element: 'u' },
            { name: 'Strikethrough',  element: 'strike' },
            { name: 'Subscript',    element: 'sub' },
            { name: 'Superscript',    element: 'sup' },
            */

            { name: 'Marker',     element: 'span', attributes: { 'class': 'marker' } },

            { name: 'Big',        element: 'big' },
            { name: 'Small',      element: 'small' },
            { name: 'Typewriter',   element: 'tt' },

            { name: 'Computer Code',  element: 'code' },
            { name: 'Keyboard Phrase',  element: 'kbd' },
            { name: 'Sample Text',    element: 'samp' },
            { name: 'Variable',     element: 'var' },

            { name: 'Deleted Text',   element: 'del' },
            { name: 'Inserted Text',  element: 'ins' },

            { name: 'Cited Work',   element: 'cite' },
            { name: 'Inline Quotation', element: 'q' },

            { name: 'Language: RTL',  element: 'span', attributes: { 'dir': 'rtl' } },
            { name: 'Language: LTR',  element: 'span', attributes: { 'dir': 'ltr' } },
            { name: 'Language: Arabic',  element: 'span', attributes: { 'arabic': 'true' } },

            /* Object Styles */

            {
              name: 'Styled image (left)',
              element: 'img',
              attributes: { 'class': 'left' }
            },

            {
              name: 'Styled image (right)',
              element: 'img',
              attributes: { 'class': 'right' }
            },

            {
              name: 'Compact table',
              element: 'table',
              attributes: {
                cellpadding: '5',
                cellspacing: '0',
                border: '1',
                bordercolor: '#ccc'
              },
              styles: {
                'border-collapse': 'collapse'
              }
            },

            { name: 'Borderless Table',   element: 'table', styles: { 'border-style': 'hidden', 'background-color': '#E6E6FA' } },
            { name: 'Square Bulleted List', element: 'ul',    styles: { 'list-style-type': 'square' } }
          ] );
            
          if (!document.getElementsByClassName) {
              document.getElementsByClassName = function (cn) { 
                  var rx = new RegExp("(?:^|\\s)" + cn+ "(?:$|\\s)");
                  var allT = document.getElementsByTagName("*"), allCN = [], ac="", i = 0, a;
                      while (a = allT[i=i+1]) {
                        ac=a.className;
                        if ( ac && ac.indexOf(cn) !==-1) {
                          if(ac===cn){ allCN[allCN.length] = a; continue;   }
                          rx.test(ac) ? (allCN[allCN.length] = a) : 0;
                        }
                      }
                  return allCN;
              }
          }
          
          if (document.getElementsByClassName){
          var e = document.getElementsByClassName( 'ckeditor1' );
          for(var i=0;i<e.length;i++)
              {
              var editor1 = CKEDITOR.replace( e[i], {toolbar: 'Full'});
              }
         }
  }

  function addEvent(element, event, fn) {
      if (element.addEventListener)
          element.addEventListener(event, fn, false);
      else if (element.attachEvent)
          element.attachEvent('on' + event, fn);
  }
  addEvent(window, 'load', function(){ bind(); });
  </script>
</apex:outputPanel>

</apex:page>